href:http://blog.csdn.net/v_JULY_v/article/details/6278484

1.把二元查找树转变成排序的双向链表（树）
题目：
输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。
要求不能创建任何新的结点，只调整指针的指向。
   10
  / /
  6  14
 / / / /
4  8 12 16
转换成双向链表
4=6=8=10=12=14=16。

思路：
中序遍历二叉树可以正确排序。 
访问过程中，保留：待加入节点、当前结点。 
使用递归遍历。
void ergodicBSTree(BSTreeNode * pCurrent){
    if(pCurrent==null) return;
    ergodicBSTree(pCurrent.left);
    addToList(pCurrent);    
    ergodicBSTree(pCurrent.right);
}
//pPrevious pHead see to all
void addToList(BSTreeNode * pCurrent){
    pCurrent->left = pPrevious;
    if(pPrevious!=null) pPrevious->right = pCurrent;
    else pHead = pCurrent;
    pPrevious = pCurrent;
}



2.设计包含min函数的栈（栈）
定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。
要求函数min、push以及pop的时间复杂度都是O(1)。

3.DP子数组最大和
  sum[i+1] = max(sum[i]+a[i+1],a[i+1])
  result = max(result,sum[i])

  http://blog.csdn.net/v_JULY_v/article/details/6126406